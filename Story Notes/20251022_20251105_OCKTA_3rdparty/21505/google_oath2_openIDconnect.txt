site: https://developers.google.com/identity/openid-connect/openid-connect

#Server Flow 
process:
1) Create an anti-forgery state Token
    to prevent security attacks, an anit-forgery token should be created to validate that the requests for authentication is valid.
creating a unique state of data for the request (ex hash of user, time, ect).

2) Send an authentication request to Google 
    request authentication from google, the base uri should be retrieved from the Discovery document using the authorazation_endpoint meta data:

    2.a) Discovery Document:
        Simplification of implementing OpenID connect there is a Discovery document that is provided that provides details on authentication:
        for google: https://accounts.google.com/.well-known/openid-configuration

    once the authorization endpoint is obtained from the discovery document, make the authorization endpoint request 
    parameters:
    - client_id: set up for a specific id for the application 
    - response_type: this could be set with a bunch of different values based on what we want to retrieve but for 
        authentication it would be set to 'code' 
    - scope: basic request set to openid email
    - redirect_uri: the http endpoint on our server that will receive the respones from google, this is configured in the 
        Cloud Console Credentials page.
    - state: this is where the anti-forgery token is sent
    - nonce: a random value generated by our app that enables replay protection when present 
    - login_hint: this can be the users login information, if not provided google will take care of it 
    
3) Confirm the anti-forgery state token 
    Once the user has authenticated on the Google authentication page, Google uses the redirect_uri that is specified in the request and 
response are returned in the query string:
exampl: https://oauth2.example.com/code?
                                   state=security_token%3D138r5719ru3e1%26url%3Dhttps%3A%2F%2Foa2cb.example.com%2FmyHome&
                                   code=4/P7q7W91a-oMsCeLvIaQm6bTrgtp7&
                                   scope=openid%20email%20https://www.googleapis.com/auth/userinfo.email

    with this, we want to confirm the state with the starting state from the beginning

4) Exchange code for access token and ID token 
    from the redirect_uri query parameters, exchange the code for a token by utizilizing the token_endpoint from the discovery document.

    the endpoint takes a post body of the following:
    - code: authorization code from the redirect_uri
    - client_id: the id we set up from the cloud console client page 
    - redirect_uri: authorized redirect URI for the given client_id specified in the cloud console client page 
    - grant_typ: set to 'authorization_code'

    a successful response looks like the following:
    - access_token: token that can be used for google api access 
    - expires_in: lifetime of the access token in seconds 
    - id_token: JWT that contains identity information about the user that is gigitally signed by google 
    - scope: the scope of the access, this is a comma seperated list of case-sensitive strings 
    - token-type: set to 'Bearer', will define the type of token returned
    - refresh_token: (optional) field only present if access_type parameter was set to offline in the authentication request

5) Obtain user information from the ID token 
see the jwt schema, for parsing the jwt token that is cryptographically signed Base64-encoded json

6) Authenticate the user 
from parsing the jwt token, we should connect the ID from the jwt token to a user in our database
Note:
- it is not recommended to key off of the email
- we should have another entity to store open ID connect IDs from the provider to the user 

##Additional Topics

#Access to other apis 

Within the atuthentication request, adding more scopes allow the application to access different points with in
the client on behalf of the user. Just including those scopes on request allows the application to access. 
Know that this has to be on the ID token 
- in step 2, request with all scopes desired
- in step 4, the response will have the scopes allowed
- then when accessing other apis, the scopes will determine whether or not access has been given 

#Refresh tokens 
for google, adding the 'offline' scope allows the refresh_token.


